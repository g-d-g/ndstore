#!/usr/bin/python

#
# Assemble tiles into a larger image
# Simple script to concatenate tiles into larger images.
#

#
# Example usage:
#   Copy images of 32x32 tiles (8192x8192 pixles) from 25 slice, starting with 3805, to /tmp/out
# python assemble-tiles.py --root=/data/brain --slice=3805 --slices=25 --cols=32 --rows=32 --col=220 --row=300 --outdir=/tmp/out
#


import argparse
import errno
import math
import os
import re
import sys
import datetime

import Image
import ImageOps

class DataInfo:
    tilesize=256

    # Number of rows at scale=0
    # rows=int(math.ceil(5200*23/256))
    rows=468

    # Number of columns at scale=0
    # cols=int(math.ceil(5200*26/256))
    cols=529

    def __init__(self):
        pass

    def getFileLocation(self, scale, slice, col, row):
        return "{0}/{1}/{2}/{3}_{4}.png".format(self.root, scale, slice, row, col)

def main():
    parser = argparse.ArgumentParser(description="Tile images into a larger image")
    parser.add_argument('--root', action="store", required=True, help="Root directory of data (do not include '/0')")
    parser.add_argument('--slice', action="store", required=True, type=int,  help="First slice to convert (int)")
    parser.add_argument('--scale', action="store", required=True, type=int, default=0, help="Scale level")
    parser.add_argument('--cols', action="store", type=int, default=1, help="Number of columns to copy")
    parser.add_argument('--rows', action="store", type=int, default=1, help="Number of rows to copy")
    parser.add_argument('--slices', action="store", type=int, default=1, help="Number of slices to convert")
    parser.add_argument('--row', action="store", type=int, default=0, help="Row to start with")
    parser.add_argument('--col', action="store", type=int, default=0, help="Column to start with")
    parser.add_argument('--outdir', action="store", default=".", help="Output directoy")

    args = parser.parse_args()

    data = DataInfo()
    data.root= args.root
    data.slice = args.slice

    # Create a README file to describe the images
    readmefile = "{0}/README.txt".format(args.outdir)
    readme = open(readmefile, 'w')
    readme.write("# Generated by {0} at {1}\n".format(os.getlogin(),
      datetime.datetime.now().__str__()))
    readme.write("# Scale: {0}\n".format(args.scale))
    readme.write("# Corner: x={0} y={1}\n".format(args.row*256, args.col*256))
    readme.write("# Size: dx={0} dy={1}\n".format(args.rows*256, args.cols*256))
    readme.write("# Slices: {0}-{1}\n".format(args.slice, args.slice+args.slices-1))
    readme.close()

    for slice in xrange(args.slice, args.slice+args.slices):
        img = Image.new("L", (256*args.cols,256*args.rows) )
        try:
            for col in xrange(args.cols):
                for row in xrange(args.rows):
                    filename = data.getFileLocation(args.scale, slice, args.row+row, args.col+col)
                    print filename
                    t = Image.open(filename)
                    img.paste(t, (256*row,256*col) )
        except:
            # Ignore I/O errors  -- the image will remain black
            # This is most likely a sign of a non-existent slice
            # TODO: Find a better way of handling this.
            pass
        outfile = "{0}/{1}.png".format(args.outdir, slice)
        print outfile
        img.save(outfile, format="PNG", optimize=1)
   
if __name__ == "__main__":
    main()
