# Copyright 2014 Open Connectome Project (http://openconnecto.me)
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import sys
import os
from contextlib import closing

import numpy as np
from PIL import Image
import cStringIO
import zlib
from contextlib import closing

sys.path.append(os.path.abspath('../../django'))
import OCP.settings
os.environ['DJANGO_SETTINGS_MODULE'] = 'OCP.settings'
from django.conf import settings

import django
django.setup()
from ocpuser.models import *  

from cube import Cube
import ocpcarest
import ocpcadb
import ocpcaproj
import ocplib

class Ingest_Data:


  def __init__( self, path, resolution):
    """ Load image stack into OCP, creating tokens and channels as needed """
    
    self.dataset_name = dataset_name
    self.dataset = Dataset.objects.get( dataset_name = self.dataset_name )

    self.project_name = '' # needed for creating channels 
    self.channels = [] # contains the names for each of the channels in this folder 

    self.resolution = resolution
    self.path = path # path to the aligned folder? 

    # set the project name based on the path
    self.project_name = self.path.split('/')[-1][:-4].replace('-', '_')
    # create the project, default token (same as project), and channels  
    self.createProject()
    for chnum, channel in enumerate(self.channels):
      self.createChannel( channel, chnum )

    # ingest the folder 
    self.ingest()

  def createDataset(self):
    """Create a dataset"""
  
  def createProject ( self ):
    """Create a project"""
    
    try:
      existing_proj = Project.objects.get(project_name = self.project_name)
      print "Project {} already exists! Skipping creation of project and token...".format(self.project_name) 
    
    except Project.DoesNotExist, e:
      new_project = Project()
      new_project.project_name = self.project_name
      new_project.user = User.objects.get(id=1)
      new_project.description = "Autogenerated from folder {} using dataset {}".format(self.project_name, self.dataset_name)
      new_project.public = 0
      new_project.dataset = self.dataset
      #new_project.host = 'dsp061.pha.jhu.edu'
      new_project.host = 'localhost'
      new_project.kvengine = 'MySQL'
      #new_project.kvserver = 'dsp061.pha.jhu.edu'
      new_project.kvserver = 'localhost'
      new_project.ocp_version = '0.6'
      new_project.schema_version = '0.6'
      new_project.save()

      pd = ocpcaproj.OCPCAProjectsDB()
      pd.newOCPCAProject( new_project.project_name )
     
      tk = Token ( token_name = new_project.project_name, token_description = 'Default token for project {}'.format(new_project.project_name), project_id=new_project, public=0, user = new_project.user )
      tk.save()
 
  def createChannel ( self, name, chnum ):
    """ create the channels """
    
    try:
      existing_channel = Channel.objects.get( channel_name = name )
      print "Channel {} already exists for project {}! Skipping creation...".format(name, self.project_name)
    except Channel.DoesNotExist, e:

      new_channel = Channel()
      new_channel.project = Project.objects.get( project_name = self.project_name )
      new_channel.channel_name = name
      new_channel.channel_description = 'Autogenerated for project {}, dataset {}, channel num {}'.format(self.project_name, self.dataset_name, chnum)
      new_channel.channel_type = 'timeseries'
      new_channel.resolution = self.resolution
      new_channel.propagate = 0
      new_channel.channel_datatype = 'uint16'
      new_channel.readonly = 0
      new_channel.exceptions = 0
      new_channel.save() 
    
      try:
        # create tables for the channel
        pd = ocpcaproj.OCPCAProjectsDB()
        pd.newOCPCAChannel( self.project_name, new_channel.channel_name )
      except Exception, e: 
        print e 
        exit()

  def ingest ( self ):
    """ Read image stack and ingest """

    # Load a database
    with closing (ocpcaproj.OCPCAProjectsDB()) as projdb:
      proj = projdb.loadToken(result.token)

    with closing (ocpcadb.OCPCADB(proj)) as db:

      ch = proj.getChannelObj(result.channel)
      # get the dataset configuration
      [[ximagesz, yimagesz, zimagesz],(starttime,endtime)] = proj.datasetcfg.imageSize(result.resolution)
      [xcubedim,ycubedim,zcubedim] = cubedim = proj.datasetcfg.getCubeDims()[result.resolution]
      [xoffset, yoffset, zoffset] = proj.datasetcfg.getOffset()[result.resolution]

      # Get a list of the files in the directories
      for slice_number in range (zoffset, zimagesz+1, zcubedim):
        slab = np.zeros([zcubedim, yimagesz, ximagesz ], dtype=np.uint32)
        for b in range(zcubedim):
          if (slice_number + b <= zimagesz):
            try:
              # reading the raw data
              file_name = "{}BrainBowExM_{:0>4}.tif".format(result.path, slice_number+b)
              print "Open filename {}".format(file_name)
              img = Image.open(file_name, 'r').convert("RGBA")
              imgdata = np.asarray(img)
              slab[b,:,:] = np.left_shift(imgdata[:,:,3], 24, dtype=np.uint32) | np.left_shift(imgdata[:,:,2], 16, dtype=np.uint32) | np.left_shift(imgdata[:,:,1], 8, dtype=np.uint32) | np.uint32(imgdata[:,:,0])
            except IOError, e:
              print e
              imgdata = np.zeros((yimagesz, ximagesz), dtype=np.uint32)
              slab[b,:,:] = imgdata

        for y in range ( 0, yimagesz+1, ycubedim ):
          for x in range ( 0, ximagesz+1, xcubedim ):

            # Getting a Cube id and ingesting the data one cube at a time
            zidx = ocplib.XYZMorton ( [x/xcubedim, y/ycubedim, (slice_number-zoffset)/zcubedim] )
            cube = Cube.getCube(cubedim, ch.getChannelType(), ch.getDataType())
            cube.zeros()

            xmin = x
            ymin = y
            xmax = min ( ximagesz, x+xcubedim )
            ymax = min ( yimagesz, y+ycubedim )
            zmin = 0
            zmax = min(slice_number+zcubedim, zimagesz+1)

            cube.data[0:zmax-zmin,0:ymax-ymin,0:xmax-xmin] = slab[zmin:zmax, ymin:ymax, xmin:xmax]
            db.putCube(ch, zidx, result.resolution, cube, update=True)

def main():

  parser = argparse.ArgumentParser(description='Ingest the TIFF data')
  parser.add_argument('path', action="store", type=str, help='Directory with the image files')
  parser.add_argument('res', action="store", type=int, help='Resolution of data')

  result = parser.parse_args(result.path, result.res )
  
          
if __name__ == "__main__":
  main()
