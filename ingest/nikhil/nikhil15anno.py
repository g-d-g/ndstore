# Copyright 2014 Open Connectome Project (http://openconnecto.me)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import sys
import os
import argparse
import cStringIO
import numpy as np
from PIL import Image
import zlib
from contextlib import closing

sys.path += [os.path.abspath('../../django')]
import OCP.settings
os.environ['DJANGO_SETTINGS_MODULE'] = 'OCP.settings'
from django.conf import settings

import imagecube
import ocplib
import ocpcarest
import ocpcaproj
import ocpcadb

class NikhilIngest:

  def __init__(self, path, resolution, token_name):
    print "In initialization"
    """ Load image stack into OCP, creating tokens and channels as needed """

    self.token = token_name
    self.resolution = resolution
    self.path = path

    with closing (ocpcaproj.OCPCAProjectsDB()) as projdb:
      self.proj = projdb.loadToken(self.token)

      channel_name = (min(glob.glob("{}*.tif".format(self.path)))).strip("_0001.tif")
      self.max_slice = int(((max(glob.glob("{}*.tif".format(path)))).strip(channel_name + "_")).strip(".tif"))
      self.createChannel(channel_name)
      self.ingest()

  def createDataset(self):
    """Create a dataset"""

  def createProject(self):
    """Create a project"""

    try:
      existing_proj = Project.objects.get(project_name=self.project_name)
      print "Project {} already exists! Skipping creation of project and token...".format(self.project_name)

    except Project.DoesNotExist, e:
      new_project = Project()
      new_project.project_name = self.project_name
      new_project.user = User.objects.get(id=1)
      new_project.description = "Autogenerated from folder {} using dataset {}".format(self.project_name, self.dataset_name)
      new_project.public = 0
      new_project.dataset = self.dataset
      #new_project.host = 'dsp061.pha.jhu.edu'
      new_project.host = 'localhost'
      new_project.kvengine = 'MySQL'
      #new_project.kvserver = 'dsp061.pha.jhu.edu'
      new_project.kvserver = 'localhost'
      new_project.ocp_version = '0.6'
      new_project.schema_version = '0.6'
      new_project.save()

      pd = ocpcaproj.OCPCAProjectsDB()
      pd.newOCPCAProject(new_project.project_name)

      tk = Token(token_name=new_project.project_name, token_description='Default token for project {}'.format(new_project.project_name), project_id=new_project, public=0, user=new_project.user)
      tk.save()

      self.token = token_name

  def createChannel(self, channel_name, index):
    """ create the channels """

    new_channel = Channel()
    new_channel.project = Project.objects.get(project_name=self.proj.getProjectName())
    new_channel.channel_name = channel_name
    new_channel.channel_description = channel_name
    new_channel.channel_type = 'annotation'
    new_channel.channel_datatype = 'unit32'
    new_channel.resolution = self.resolution
    new_channel.propagate = 0
    new_channel.readonly = 0
    new_channel.exceptions = 0
    new_channel.save()

    try:
      # create tables for the channel
      pd = ocpcaproj.OCPCAProjectsDB()
      pd.newOCPCAChannel(self.proj.getProjectName(), new_channel.channel_name)
    except Exception, e:
      print e
      exit()

  def ingest(self):
    """ Read image stack and ingest """

    # Load a database
    with closing(ocpcaproj.OCPCAProjectsDB()) as projdb:
      proj = projdb.loadToken(self.token)

    with closing(ocpcadb.OCPCADB(proj)) as db:

      ch = proj.getChannelObj(self.channel_name)
      # get the dataset configuration
      [[ximagesz, yimagesz, zimagesz], (starttime, endtime)] = proj.datasetcfg.imageSize(self.resolution)
      [xcubedim, ycubedim, zcubedim] = cubedim = proj.datasetcfg.getCubeDims()[self.resolution]
      [xoffset, yoffset, zoffset] = proj.datasetcfg.getOffset()[self.resolution]

      # Get a list of the files in the directories


      for slice_number in range(zoffset, self.max_slice, zcubedim):
        slab = np.zeros([zcubedim, yimagesz, ximagesz], dtype=np.uint32)


        for b in range(zcubedim):
          file_name = "{}{}_{}.tif".format(self.path, channel_name, sl+b)
          print "Open filename {}".format(file_name)

          try:
            img = Image.open(file_name,'r')
            slab [b,:,:] = np.asarray(img)
          except IOError, e:
            print "Failed to open file %s" % (e)
            img = np.zeros((yimagesz,ximagesz), dtype=np.uint8)
            slab [b,:,:] = img

        for y in range(0, yimagesz + 1, ycubedim):
          for x in range(0, ximagesz + 1, xcubedim):

            # Getting a Cube id and ingesting the data one cube at a time
            zidx = ocplib.XYZMorton([x / xcubedim, y / ycubedim, (slice_number - zoffset) / zcubedim])
            cube = Cube.getCube(cubedim, ch.getChannelType(), ch.getDataType())
            cube.zeros()

            xmin = x
            ymin = y
            xmax = min(ximagesz, x + xcubedim)
            ymax = min(yimagesz, y + ycubedim)
            zmin = 0
            zmax = min(slice_number + zcubedim, zimagesz + 1)

            cube.data[0:zmax - zmin, 0:ymax - ymin, 0:xmax - xmin] = slab[zmin:zmax, ymin:ymax, xmin:xmax]
            db.annotateDense ( zidx, self.resolution, cube )


def main():

  parser = argparse.ArgumentParser(description='Ingest a OCP stack')
  parser.add_argument('token', action="store")
  parser.add_argument('resolution', action="store", type=int)
  parser.add_argument('path', action="store")

  result = parser.parse_args()

  ni = NikhilIngest ( result.token, result.resolution, result.path )
  ni.ingest()

if __name__ == "__main__":
  main()
