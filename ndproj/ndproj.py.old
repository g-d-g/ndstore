# Copyright 2014 NeuroData (http://neurodata.io)
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import math
import MySQLdb
import numpy as np
from contextlib import closing
from operator import add, mul

# need imports to be conditional
try:
  from cassandra.cluster import Cluster
except:
   pass
try:
  import riak
except:
   pass
try:
  import boto3
except:
  pass

from django.core.exceptions import ObjectDoesNotExist
from django.conf import settings

from nduser.models import Project
from nduser.models import Dataset
from nduser.models import Token
from nduser.models import Channel
import annotation
from ndtype import IMAGE_CHANNELS, ANNOTATION_CHANNELS, ZSLICES, ISOTROPIC, READONLY_TRUE, READONLY_FALSE, PUBLIC_TRUE, NOT_PROPAGATED, UNDER_PROPAGATION, PROPAGATED, IMAGE, ANNOTATION, TIMESERIES, MYSQL, CASSANDRA, RIAK, DYNAMODB, REDIS,  ND_servermap, SUPERCUBESIZE

from ndwserror import NDWSError
import logging
logger=logging.getLogger("neurodata")


"""While this is not a true inheritance hierarchy from NDDataset->OPCPCAProject->NDChannel modeling it as such makes it easier to call things on the channel.  It has dataset properties, etc."""






class NDProjectsDB:
  """Database for the projects"""

  def __init__(self):
    """Create the database connection"""

    self.conn = MySQLdb.connect (host = settings.DATABASES['default']['HOST'], user = settings.DATABASES['default']['USER'], passwd = settings.DATABASES['default']['PASSWORD'], db = settings.DATABASES['default']['NAME']) 

  # for context lib closing
  def close (self):
    pass

  def newNDProject ( self, project_name ):
    """Make the database for a project."""

    pr = Project.objects.get(project_name=project_name)

    if pr.kvengine == MYSQL:
      with closing(MySQLdb.connect (host = pr.host , user = settings.DATABASES['default']['USER'], passwd = settings.DATABASES['default']['PASSWORD'])) as conn:
        with closing(conn.cursor()) as cursor:

          try:
            # Make the database 
            sql = "CREATE DATABASE {}".format(pr.project_name)
         
            cursor.execute ( sql )
            conn.commit()
          except MySQLdb.Error, e:
            logger.error ("Failed to create database for new project {}: {}. sql={}".format(e.args[0], e.args[1], sql))
            raise NDWSError ("Failed to create database for new project {}: {}. sql={}".format(e.args[0], e.args[1], sql))
    
    elif pr.kvengine == CASSANDRA:
      
      try:
        server_address = ND_servermap[pr.kvserver]
        cluster = Cluster([server_address])
        session = cluster.connect()
        if server_address == 'localhost':  
          session.execute ("CREATE KEYSPACE {} WITH REPLICATION = {{ 'class' : 'SimpleStrategy', 'replication_factor' : 0 }}".format(pr.project_name), timeout=30)
        else:
          session.execute ("CREATE KEYSPACE {} WITH REPLICATION = {{ 'class' : 'SimpleStrategy', 'replication_factor' : 1 }}".format(pr.project_name), timeout=30)
      except Exception, e:
        pr.delete()
        logger.error("Failed to create namespace for new project {}".format(project_name))
        raise NDWSError("Failed to create namespace for new project {}".format(project_name))
      finally:
        session.shutdown()

    elif pr.kvengine in [DYNAMODB, REDIS]:
      # nothing to do, WOW!
      pass
    
    else:
      logging.error ("Unknown KV Engine requested: {}".format("RBTODO get name"))
      raise NDWSError ("Unknown KV Engine requested: {}".format("RBTODO get name"))


  def newNDChannel ( self, project_name, channel_name ):
    """Make the tables for a channel."""

    pr = Project.objects.get(project_name=project_name)
    ch = Channel.objects.get(channel_name=channel_name, project_id=project_name)
    ds = Dataset.objects.get(dataset_name=pr.dataset_id)

    # Connect to the database

    if pr.kvengine == MYSQL:
      with closing (MySQLdb.connect(host = pr.host, user = settings.DATABASES['default']['USER'], passwd = settings.DATABASES['default']['PASSWORD'], db = pr.project_name)) as conn:
        with closing(conn.cursor()) as cursor:
          
          try:
            # tables specific to all other non time data
            if ch.channel_type not in [TIMESERIES]:
              for i in range(ds.scalinglevels+1): 
                cursor.execute ( "CREATE TABLE {}_res{} ( zindex BIGINT PRIMARY KEY, cube LONGBLOB )".format(ch.channel_name, i) )
                # index table for each res
                cursor.execute ( "CREATE TABLE {}_res{}_index (zindex BIGINT NOT NULL PRIMARY KEY)".format(ch.channel_name, i) )
            # tables specific to timeseries data
            elif ch.channel_type == TIMESERIES:
              for i in range(ds.scalinglevels+1): 
                cursor.execute ( "CREATE TABLE {}_res{} ( zindex BIGINT, timestamp INT, cube LONGBLOB, PRIMARY KEY(zindex,timestamp))".format(ch.channel_name,i) )
                # index table for each res
                cursor.execute ( "CREATE TABLE {}_res{}_index (zindex BIGINT NOT NULL, timestamp INT NOT NULL, PRIMARY KEY(zindex,timestamp))".format(ch.channel_name, i) )
            else:
              raise NDWSError("Channel type {} does not exist".format(ch.channel_type()))
            
            # tables specific to annotation projects
            if ch.channel_type == ANNOTATION: 
              cursor.execute("CREATE TABLE {}_ids ( id BIGINT PRIMARY KEY)".format(ch.channel_name))
              # And the RAMON objects
              cursor.execute ( "CREATE TABLE {}_ramon ( annoid BIGINT, kv_key VARCHAR(255), kv_value VARCHAR(20000), PRIMARY KEY ( annoid, kv_key ))".format(ch.channel_name))
              for i in range(ds.scalinglevels+1):
                cursor.execute ( "CREATE TABLE {}_exc{} ( zindex BIGINT, id BIGINT, exlist LONGBLOB, PRIMARY KEY ( zindex, id))".format(ch.channel_name,i))
                cursor.execute ( "CREATE TABLE {}_idx{} ( annid BIGINT PRIMARY KEY, cube LONGBLOB )".format(ch.channel_name,i))
           
            # Commiting at the end
            conn.commit()
          except MySQLdb.Error, e:
            ch.delete()
            logging.error ("Failed to create tables for new project {}: {}.".format(e.args[0], e.args[1]))
            raise NDWSError ("Failed to create tables for new project {}: {}.".format(e.args[0], e.args[1]))

    elif pr.kvengine == RIAK:
      #RBTODO figure out new schema for Riak
      rcli = riak.RiakClient(host=pr.kvserver, pb_port=8087, protocol='pbc')
      bucket = rcli.bucket_type("nd{}".format(proj.getProjectType())).bucket(proj.getDBName())
      bucket.set_property('allow_mult',False)

    elif pr.kvengine == CASSANDRA:
      try:
        if ch.channel_type not in [TIMESERIES]:
          cluster = Cluster([pr.kvserver])
          session = cluster.connect(pr.project_name)
          session.execute ( "CREATE table {}_cuboids ( resolution int, zidx bigint, cuboid text, PRIMARY KEY ( resolution, zidx ) )".format(ch.channel_name), timeout=30)
        #session.execute( "CREATE table exceptions ( resolution int, zidx bigint, annoid bigint, exceptions text, PRIMARY KEY ( resolution, zidx, annoid ) )", timeout=30)
        #session.execute("CREATE table indexes ( resolution int, annoid bigint, cuboids text, PRIMARY KEY ( resolution, annoid ) )", timeout=30)
      except Exception, e:
        ch.delete()
        logging.error("Failed to create table for channel {}".format(channel_name))
        raise NDWSError("Failed to create table for channel {}".format(channel_name))
      finally:
        session.shutdown()

    elif pr.kvengine == DYNAMODB:

      try:
        # connect to dynamo
        dynamodb = boto3.resource('dynamodb')
  
        ctable = dynamodb.create_table(
          # RBTODO add user name
          TableName='{}_{}'.format(pr.project_name,ch.channel_name),
          KeySchema=[
            {
              'AttributeName': 'cuboidkey',
              'KeyType': 'HASH'
            },
          ],
          AttributeDefinitions=[
            {
              'AttributeName': 'cuboidkey',
              'AttributeType': 'S'
            },
            {
              'AttributeName': 'cuboid',
              'AttributeType': 'B'
            },
          ],
          ProvisionedThroughput={
        	  'ReadCapacityUnits': 10,
		        'WriteCapacityUnits': 10
          },
        )

        itable = dynamodb.create_table(
          TableName='{}_{}_idx'.format(pr.project_name,ch.channel_name),
          KeySchema=[
            {
              'AttributeName': 'idxkey',
              'KeyType': 'HASH'
            },
          ],
          AttributeDefinitions=[
            {
              'AttributeName': 'idxkey',
              'AttributeType': 'S'
            },
            {
              'AttributeName': 'idx',
              'AttributeType': 'B'
            },
          ],
          ProvisionedThroughput={
		        'ReadCapacityUnits': 10,
		        'WriteCapacityUnits': 10
          },
        )
  
        etable = dynamodb.create_table(
          TableName='{}_{}_exc'.format(pr.project_name,ch.channel_name),
          KeySchema=[
            {
              'AttributeName': 'exckey',
              'KeyType': 'HASH'
            },
          ],
          AttributeDefinitions=[
            {
              'AttributeName': 'exckey',
              'AttributeType': 'S'
            },
            {
              'AttributeName': 'exc',
              'AttributeType': 'B'
            },
          ],
          ProvisionedThroughput={
  		      'ReadCapacityUnits': 10,
		        'WriteCapacityUnits': 10
          },
        )
  
        # wait for the tables to exist
        ctable.meta.client.get_waiter('table_exists').wait(TableName='{}_{}'.format(pr.project_name,ch.channel_name))
        itable.meta.client.get_waiter('table_exists').wait(TableName='{}_{}_idx'.format(pr.project_name,ch.channel_name))
        etable.meta.client.get_waiter('table_exists').wait(TableName='{}_{}_exc'.format(pr.project_name,ch.channel_name))
      
      except Exception, e:
        import pdb; pdb.set_trace()
    
    elif pr.kvengine == REDIS:
      # Do nothing
      pass

    else:
      logging.error ("Unknown KV Engine requested: {}".format("RBTODO get name"))
      raise NDWSError ("Unknown KV Engine requested: {}".format("RBTODO get name"))


  def deleteNDDB (self, project_name):

    pr = Project.objects.get(project_name = project_name)

    if pr.kvengine == MYSQL:
      with closing(MySQLdb.connect (host = pr.host, user = settings.DATABASES['default']['USER'], passwd = settings.DATABASES['default']['PASSWORD'])) as conn:
        with closing(conn.cursor()) as cursor:
        # delete the database
          sql = "DROP DATABASE {}".format(pr.project_name)

          try:
            cursor.execute(sql)
            conn.commit()
          except MySQLdb.Error, e:
            # Skipping the error if the database does not exist
            if e.args[0] == 1008:
              logger.warning("Database {} does not exist".format(pr.project_name))
              pass
            else:
              conn.rollback()
              logger.error ("Failed to drop project database {}: {}. sql={}".format(e.args[0], e.args[1], sql))
              raise NDWSError ("Failed to drop project database {}: {}. sql={}".format(e.args[0], e.args[1], sql))


    elif pr.kvengine == CASSANDRA:
      try:
        cluster = Cluster( [pr.kvserver] )
        session = cluster.connect()
        session.execute ( "DROP KEYSPACE {}".format(pr.project_name), timeout=30 )
      except Exception, e:
        logger.warning("Keyspace {} does not exist".format(pr.project_name))
        pass
      finally:
        cluster.shutdown()

    elif pr.kvengine == RIAK:
      # connect to Riak
      rcli = riak.RiakClient(host=proj.kvserver, pb_port=8087, protocol='pbc')
      bucket = rcli.bucket_type("nd{}".format(proj.getProjectType())).bucket(proj.getDBName())

      key_list = rcli.get_keys(bucket)

      for k in key_list:
        bucket.delete(k)

    elif pr.kvengine == DYNAMODB:

      # connect to dynamo
      dynamodb = boto3.resource('dynamodb')

      # iterate over all the possible tables.  No name space delete.
      pr = NDProject(proj)
      chs = Channel.objects.filter(project_id=pr)
      for ch in chs:
        self.deleteNDChannel ( proj, ch.channel_name )
    
    elif pr.kvengine == REDIS:

      # Do nothing
      pass


  def deleteNDChannel (self, proj, channel_name):
    """Delete the tables for this channel"""

    pr = NDProject(proj)
    ch = NDChannel(pr, channel_name)
    table_list = []


    if pr.getKVEngine() == MYSQL:

      if ch.getChannelType() in ANNOTATION_CHANNELS:
        table_list.append(ch.getIdsTable())
        for key in annotation.anno_dbtables.keys():
          table_list.append(ch.getAnnoTable(key))

      for i in pr.datasetcfg.getResolutions():
        table_list.append(ch.getTable(i))
        if ch.getChannelType() in ANNOTATION_CHANNELS:
          table_list = table_list + [ch.getIdxTable(i), ch.getExceptionsTable(i)]

      try:
        conn = MySQLdb.connect (host = pr.getDBHost(), user = settings.DATABASES['default']['USER'], passwd = settings.DATABASES['default']['PASSWORD'], db = pr.getProjectName() ) 
        # delete the tables for this channel
        sql = "DROP TABLES IF EXISTS {}".format(','.join(table_list))
      
        with closing(conn.cursor()) as cursor:
          cursor.execute (sql)
          conn.commit()
      except MySQLdb.Error, e:
        # Skipping the error if the table does not exist
        if e.args[0] == 1051:
          pass
        if e.args[0] == 1049:
          pass
        else:
          conn.rollback()
          logger.error ("Failed to drop channel tables {}: {}. sql={}".format(e.args[0], e.args[1], sql))
          raise NDWSError ("Failed to drop channel tables {}: {}. sql={}".format(e.args[0], e.args[1], sql))
      
    elif pr.getKVEngine() == CASSANDRA:
      # KL TODO
      pass
    
    elif pr.getKVEngine() == RIAK:
      # KL TODO
      pass

    elif pr.getKVEngine() == DYNAMODB:

      import pdb; pdb.set_trace()
      dynamodb = boto3.resource('dynamodb')
      table_list = [ '{}_{}'.format(pr.getProjectName(),ch.getChannelName()),\
                     '{}_{}_idx'.format(pr.getProjectName(),ch.getChannelName()),\
                     '{}_{}_exc'.format(pr.getProjectName(),ch.getChannelName()) ]
      for tbl in table_list:
        try:
          table = dynamodb.Table(tbl)
          table.delete()
        except Exception, e:
          import pdb; pdb.set_trace()
          raise

    elif pr.getKVEngine() == REDIS:
      
      # Do nothing
      pass
      

  def loadDatasetConfig ( self, dataset ):
    """Query the database for the dataset information and build a db configuration"""
    return NDDataset (dataset)

  def loadToken ( self, token ):
    """Query django configuration for a token to bind to a project"""
    return NDProject (token)

  def getPublicTokens ( self ):
    """ Return a list of public tokens """

    tkns = Token.objects.filter(public = PUBLIC_TRUE)
    return [t.token_name for t in tkns]
  
  def getPublicDatasets ( self ):
    """ Return a list of public datasets """
    
    datasets = Dataset.objects.filter(public = PUBLIC_TRUE)
    return [d.dataset_name for d in datasets]
